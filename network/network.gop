package network

import (
	"base/common"
	"context"
	"crypto/rand"
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"fmt"
	"io"
	"log"
	"math/big"
	"net"
	"sync"
	"time"

	"capnproto.org/go/capnp/v3"
	quic "github.com/quic-go/quic-go"
)

type Event struct {
	chat chan *common.Message
}

type Server struct {
	listener       quic.Listener
	acceptDatagram bool
	acceptSession  bool
	testDatagram   bool
	testStream     bool
	channels       Event
	streams        []Stream
}

func NewServer(acceptDatagram, acceptSession, testDatagram, testStream bool) *Server {
	listener, err := listen()
	if err != nil {
		log.Fatalf("Failed to listen: %v", err)
	}

	return &Server{
		listener:       *listener,
		acceptDatagram: acceptDatagram,
		acceptSession:  acceptSession,
		testDatagram:   testDatagram,
		testStream:     testStream,
		channels: Event{
			chat: make(chan *common.Message, 100),
		},
	}
}

func listen() (*quic.Listener, error) {
	tlsConfig := generateTLSConfig()

	udpConn, err := net.ListenUDP("udp4", &net.UDPAddr{Port: 1234})
	if err != nil {
		return nil, err
	}
	tr := quic.Transport{
		Conn: udpConn,
	}
	ln, err := tr.Listen(tlsConfig, &quic.Config{EnableDatagrams: true})
	if err != nil {
		return nil, err
	}
	fmt.Println("QUIC server is listening on", ln.Addr())
	return ln, nil
}

func (server *Server) AcceptConnections() error {
	for {
		conn, err := NewConnection(server.listener.Accept(context.Background()))
		if err != nil {
			return err
		}
		if server.acceptSession {
			go server.handleSession(conn)
		}
		if server.acceptDatagram {
			go handleDatagram(conn, &server.channels)
		}
		if server.testDatagram {
			go conn.sendData()
		}
	}
}

func (connection *Connection) sendData() {
	for {
		select {

		case <-connection.Context().Done():
			fmt.Println("Data sender stopping.")
			return
		default:
			// Send a datagram to the client
			chatMessage, err := CreateChatMessage(common.Message{PlayerId: 16, Text: "1 datagram msg"})
			err = connection.SendDatagram(chatMessage)
			if err != nil {
				fmt.Printf("Error sending datagram: %v\n", err)
				break
			}
			fmt.Println("Datagram sent successfully.")
			time.Sleep(1 * time.Second)
		}
	}
}

func sendStreamData(stream Stream) error {
	for {
		select {

		case <-stream.Context().Done():
			fmt.Println("Data sender stopping.")
			return nil
		default:
			chatMessage, err := CreateChatMessage(common.Message{PlayerId: 5, Text: "asdaasdsd"})
			if err != nil {
				fmt.Printf("Error creating message: %s\n", err)
				return err
			}
			// channels.chat <- chatMessage
			err = stream.WriteStream(chatMessage)
			if err != nil {
				fmt.Printf("Error sending data: %s\n", err)
				return err
			}
			// fmt.Println("Ping message sent successfully.") // valid: once per stream
			time.Sleep(1 * time.Second)
		}

	}
}

func (server *Server) handleSession(conn *Connection) {
	// defer conn.CloseWithError(0, "bye")
	for {
		select {

		case <-conn.Context().Done():
			fmt.Println("Data sender stopping.")
			return
		default:
			stream, err := conn.AcceptStream(context.Background())
			if err != nil {
				fmt.Printf("Error accepting stream: %v\n", err)
				break
			}
			fmt.Println("Accepted new stream.")
			server.streams = append(server.streams, Stream{stream})

			if server.testStream {
				go sendStreamData(Stream{stream})
			}
			go unknownName(stream, &server.channels)
		}

	}
}

func (server *Server) BroadcastChat() {
	//read from channel
	fmt.Println("broadcasting ready")
	for {
		msg, ok := <-server.channels.chat
		if !ok {
			log.Println("Chat channel closed")
			return
		}
		fmt.Printf("broadcasting msg to: %d clients\n", len(server.streams))
		cm, _ := CreateChatMessage(*msg)
		for _, s := range server.streams {
			_ = s.WriteStream(cm)
		}
	}
}

func handleDatagram(conn *Connection, channels *Event) error {
	// defer conn.CloseWithError(0, "bye")
	for {
		datagram, err := conn.ReceiveDatagram(context.Background())
		if err != nil {
			log.Println("Failed to receive datagram:", err)
			return err
		}
		log.Printf("Accepted new Datagram")
		msg, err := capnp.Unmarshal(datagram)
		if err != nil {
			log.Printf("Failed to unmarshal message: %v", err)
			return err
		}

		HandleGameMessage(msg, channels, "datagram")
	}
}

func unknownName(stream quic.Stream, channels *Event) {
	msg := decode(stream)
	HandleGameMessage(msg, channels, "stream") // needs goroutine?
}

func decode(stream quic.Stream) *capnp.Message {
	decoder := capnp.NewDecoder(stream)
	msg, err := decoder.Decode()
	if err != nil {
		if err == io.EOF {
			fmt.Println("Stream closed by client.")
			return nil
		}
		log.Println("Failed to decode message:", err)
	}
	return msg
	// switch gameMsg.Which() {
	// case common.GameMessage_Which_playerMove:
	// 	_, _ = gameMsg.PlayerMove()
	// 	fmt.Println("PlayerMove")
	// case common.GameMessage_Which_playerAction:
	// 	_, _ = gameMsg.PlayerAction()
	// 	fmt.Println("PlayerAction")
	// case common.GameMessage_Which_gameStateUpdate:
	// 	_, _ = gameMsg.GameStateUpdate()
	// 	fmt.Println("GameStateUpdate")
	// case common.GameMessage_Which_chatMessage:
	// 	msg := ParseChatMessage(gameMsg)
	// 	log.Printf("Received Streamed chat message: %d %s", msg.PlayerId, msg.Text)
	// }
}

// generateTLSConfig creates a TLS configuration for the QUIC server
func generateTLSConfig() *tls.Config {
	key, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		panic(err)
	}
	serialNumber, _ := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 128))
	cert := &x509.Certificate{
		SerialNumber: serialNumber,
		Subject: pkix.Name{
			Organization: []string{"Company, INC."},
		},
		NotBefore:             time.Now(),
		NotAfter:              time.Now().Add(time.Hour * 24),
		KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		BasicConstraintsValid: true,
	}

	certBytes, err := x509.CreateCertificate(rand.Reader, cert, cert, &key.PublicKey, key)
	if err != nil {
		panic(err)
	}
	certPEM := pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: certBytes})
	keyPEM := pem.EncodeToMemory(&pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(key)})

	tlsCert, err := tls.X509KeyPair(certPEM, keyPEM)
	if err != nil {
		panic(err)
	}

	return &tls.Config{
		Certificates: []tls.Certificate{tlsCert},
		NextProtos:   []string{"quic-echo-example"},
	}
}

type Client struct {
	ServerAddr string
	Connection *Connection
	Transport  *quic.Transport
	Channels   Event
}

type Stream struct {
	quic.Stream
}

type Connection struct {
	quic.Connection
}

func NewClient(serverAddr string) *Client {
	return &Client{
		ServerAddr: serverAddr,
		Channels: Event{
			chat: make(chan *common.Message, 100),
		},
	}
}

func (client *Client) NewStream() (*Stream, error) {
	stream, err := client.Connection.OpenStream()
	if err != nil {
		return nil, err
	}

	log.Println("QUIC connection established successfully.")
	return &Stream{
		stream,
	}, nil
}

func NewConnection(connection quic.Connection, error error) (*Connection, error) {
	return &Connection{
		connection,
	}, nil
}

func (client *Client) Connect() error {
	conn, err := net.ListenUDP("udp4", &net.UDPAddr{})
	if err != nil {
		log.Println("Failed to listen ofn UDP:", err)
		return err
	}

	// Setup QUIC transport using the listening connection
	client.Transport = &quic.Transport{
		Conn: conn,
	}

	remoteAddr, err := net.ResolveUDPAddr("udp", client.ServerAddr)
	if err != nil {
		log.Println("Failed to resolve server UDP address:", err)
		return err
	}

	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()
	client.Connection, err = NewConnection(client.Transport.Dial(ctx, remoteAddr, &tls.Config{
		InsecureSkipVerify: true, // For testing only; ensure proper TLS config in production
		NextProtos:         []string{"quic-echo-example"},
	}, &quic.Config{
		EnableDatagrams: true,
	}))
	if err != nil {
		log.Println("QUIC dial failed:", err)
		return err
	}

	return nil
}

func (client *Client) Close() error {
	if client.Connection != nil {
		return client.Connection.CloseWithError(0, "client closing connection")
	}
	return nil
}

func (stream *Stream) Receive(channels *Event, wg *sync.WaitGroup) error {
	defer wg.Done()
	for {
		unknownName(stream, channels)
		// log.Printf("Received chatmsg: %s", "text")
		// stream.Close()
	}

}

func (connection *Client) ReceiveDatagram(channels *Event, wg *sync.WaitGroup) error {
	defer wg.Done()
	for {
		datagram, err := connection.Connection.ReceiveDatagram(context.Background())
		if err != nil {
			log.Println("Failed to receive datagram")
		}
		msg, err := capnp.Unmarshal(datagram)
		if err != nil {
			log.Printf("Failed to unmarshal message: %v", err)
			return err
		}

		HandleGameMessage(msg, channels, "datagram")
	}
	return nil
}
