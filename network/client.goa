// package network

// import (
// 	"base/common"
// 	"context"
// 	"crypto/tls"
// 	"fmt"
// 	"log"
// 	"net"
// 	"time"

// 	"capnproto.org/go/capnp/v3"
// 	quic "github.com/quic-go/quic-go"
// )

// type Client struct {
// 	ServerAddr string
// 	connection quic.Connection
// 	Transport  *quic.Transport
// }

// type Stream struct {
// 	quic.Stream
// }

// func NewClient(serverAddr string) *Client {
// 	return &Client{
// 		ServerAddr: serverAddr,
// 	}
// }

// func (c *Client) NewStream(serverAddr string) *Stream {
// 	stream, _ := c.OpenStream()
// 	return &Stream{
// 		stream,
// 	}
// }

// func (c *Client) Connect() error {
// 	localAddr, err := net.ResolveUDPAddr("udp", "0.0.0.0:0") // Listen on any available port
// 	if err != nil {
// 		log.Println("Failed to resolve local UDP address:", err)
// 		return err
// 	}

// 	// Listening without connecting to a specific server address
// 	conn, err := net.ListenUDP("udp", localAddr)
// 	if err != nil {
// 		log.Println("Failed to listen on UDP:", err)
// 		return err
// 	}

// 	log.Println("UDP listener setup successfully, setting up QUIC transport...")

// 	remoteAddr, err := net.ResolveUDPAddr("udp", c.ServerAddr)
// 	if err != nil {
// 		log.Println("Failed to resolve server UDP address:", err)
// 		return err
// 	}

// 	// Setup QUIC transport using the listening connection
// 	c.Transport = &quic.Transport{
// 		Conn: conn,
// 	}

// 	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
// 	defer cancel()
// 	c.connection, err = c.Transport.Dial(ctx, remoteAddr, &tls.Config{
// 		InsecureSkipVerify: true, // For testing only; ensure proper TLS config in production
// 		NextProtos:         []string{"quic-echo-example"},
// 	}, &quic.Config{
// 		EnableDatagrams: true,
// 	})
// 	if err != nil {
// 		log.Println("QUIC dial failed:", err)
// 		return err
// 	}

// 	log.Println("QUIC connection established successfully.")
// 	return nil
// }

// func (c *Client) OpenStream() (quic.Stream, error) {
// 	stream, err := c.connection.OpenStream()
// 	if err != nil {
// 		return nil, err
// 	}
// 	return stream, nil
// }

// func (stream Stream) SendMessage(message string) error {
// 	_, err := fmt.Fprintf(stream, message)
// 	if err != nil {
// 		return fmt.Errorf("failed to send message: %w", err)
// 	}
// 	return nil
// }

// // Send sends data to the server and reads the response
// func (c *Client) SendDatagram(data string) error {
// 	err := c.connection.SendDatagram([]byte(data))
// 	if err != nil {
// 		return fmt.Errorf("failed to send datagram: %w", err)
// 	}
// 	fmt.Printf("Sent: %s\n", data)

// 	// Read the server's response
// 	// buf := make([]byte, len(data))
// 	// _, err = io.ReadFull(c.stream, buf)
// 	// if err != nil {
// 	// 	return fmt.Errorf("cannot read from server: %w", err)
// 	// }

// 	// fmt.Printf("Received: %s\n", string(buf))
// 	return nil
// }
// func (stream Stream) WriteStream(data string) error {
// 	// defer stream.Close() // Ensure the stream is closed after all operations are done
// 	// defer c.connection.CloseWithError(0, "client closing stream")
// 	// Prepare the Cap'n Proto message
// 	msg, seg, err := capnp.NewMessage(capnp.SingleSegment(nil))
// 	if err != nil {
// 		log.Fatal("Failed to create new Cap'n Proto message:", err)
// 		return err
// 	}

// 	message, err := common.NewRootGameMessage(seg)
// 	if err != nil {
// 		log.Fatal("Failed to create root game message:", err)
// 		return err
// 	}

// 	ping, err := message.NewChatMessage()
// 	if err != nil {
// 		log.Fatal("Failed to create chat message:", err)
// 		return err
// 	}

// 	ping.SetPlayerId(1)
// 	ping.SetText(data)

// 	// Encode and send the message
// 	if err := capnp.NewEncoder(c.stream).Encode(msg); err != nil {
// 		log.Fatal("Failed to encode and send message:", err)
// 		return err
// 	}
// 	// _, err := fmt.Fprintf(stream, ping)
// 	fmt.Println("Ping message sent successfully.")
// 	// buf := make([]byte, len(data))
// 	// _, err = io.ReadFull(c.stream, buf)
// 	// if err != nil {
// 	// 	return fmt.Errorf("cannot read from server: %w", err)
// 	// }

// 	// fmt.Printf("Received: %s\n", string(buf))
// 	return nil
// }

// // Close properly closes the stream and session
// func (c *Client) Close() error {
// 	if c.stream != nil {
// 		c.stream.Close()
// 	}
// 	if c.connection != nil {
// 		return c.connection.CloseWithError(0, "client closing connection")
// 	}
// 	return nil
// }
